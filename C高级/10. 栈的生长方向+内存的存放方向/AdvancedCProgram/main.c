//
//  main.c
//  AdvancedCProgram
//
//  Created by Yu Yang on 8/23/23.
//

#define _CRI_SECURE_NO_WARNINGS
// VS下使用传统库函数, 会建议用_s更安全的函数, 如果不用会报错 C4996

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


// 栈的生长方向
void func1(void) {
    int a = 10;     //栈底 高地址
    int b = 11;
    int c = 12;
    int d = 13;     //栈顶 低地址

    printf("%p\n", &a);
    printf("%p\n", &b);
    printf("%p\n", &c);
    printf("%p\n", &d);

//    0x7ff7bfeff24c
//    0x7ff7bfeff248
//    0x7ff7bfeff244
//    0x7ff7bfeff240

}


// 内存的存放方向
void func2(void) {
    int a = 0x11223344;
    int b = 0x55667788;
    char *pa = (char *)&a;
    char *pb = (char *)&b;
    printf("%x\n", *pa);
    printf("%x\n", *(pa+1));
    
    printf("%x\n", *pb);
    printf("%x\n", *(pb+1));
}

int main() {
//    func1();
    
    func2();
    
    return EXIT_SUCCESS;
}


/*
 来自ChatGPT4
 
 ------------------------------------------------------------------------------------------------------------------------
 c语言中,下面代码执行结果如何
 void func2(void) {
    int a = 0x11223344;
    int b = 0x55667788;
    char *pa = (char *)&a;
    char *pb = (char *)&b;
    printf("%x\n", *pa);
    printf("%x\n", *(pa+1));

    printf("%d\n", *pb);
    printf("%d\n", *(pb+1));
 }
 ------------------------------------------------------------------------------------------------------------------------
 这段代码的执行结果依赖于你机器的字节序(endianness)。

 如果你的机器是大端模式(big-endian)，内存中高位字节放在低地址，低位字节放在高地址。所以打印结果将为：

 11
 22
 55
 66

 如果你的机器是小端模式(little-endian)，内存中高位字节放在高地址，低位字节放在低地址。所以打印结果将为：

 44
 33
 88
 77

 需要注意的是，这里的printf使用了%x格式符，它表示打印16进制整数，但是pa和pb被强制类型转换为char*，所以*pa和*(pa+1)实际上获取的只是a的一部分内容（一个字节）。同样的道理也适用于pb。对于不同的字节序，这些内容的顺序是不一样的。
 ------------------------------------------------------------------------------------------------------------------------
 我的机器是小端模式, 但是打印的是
 44
 33
 ffffff88
 77

 为什么是ffffff88?
 ------------------------------------------------------------------------------------------------------------------------
 这是因为在C语言中，char可能被视为有符号类型。当你使用"%x"来打印一个负数时，它会以补码的形式显示。

 "0x88"转换为十进制数是136，如果我们将它看作是一个有符号的字节，那么最高位就是符号位，也就是说它实际上代表的是一个负数（-120）。对于一个负整数，它的补码表示方法是取绝对值，然后按位取反，最后加1。

 所以，这里的"0x88"在内存中实际上是以"0xFFFFFF88"的形式存在的，这就是为什么printf("%x", *pb)打印出来的是"FFFFFF88"。

 如果你希望打印出正确的结果，你可以将`char *pb`改为`unsigned char *pb`，这样的话，无论char是否被视为有符号类型，都能够得到预期的输出。
 ------------------------------------------------------------------------------------------------------------------------

 
 */


/*
 "0x88"转换为十进制数是136
 字节0x88大于127（char的最大值）
 所以它将0x88视为一个负数
 */
